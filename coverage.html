
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>storage: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">pass-cli/internal/storage/atomic_save.go (62.3%)</option>
				
				<option value="file1">pass-cli/internal/storage/storage.go (59.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package storage

import (
        "crypto/rand"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// generateTempFileName creates unique temp file name with timestamp + random suffix
// Format: vault.enc.tmp.YYYYMMDD-HHMMSS.XXXXXX
func (s *StorageService) generateTempFileName() string <span class="cov8" title="1">{
        timestamp := time.Now().Format("20060102-150405")
        suffix := randomHexSuffix(6)
        return fmt.Sprintf("%s.tmp.%s.%s", s.vaultPath, timestamp, suffix)
}</span>

// randomHexSuffix generates N-character hex suffix from crypto/rand
func randomHexSuffix(length int) string <span class="cov8" title="1">{
        bytes := make([]byte, length/2) // 2 hex chars per byte
        // crypto/rand.Read always returns len(bytes), nil in practice
        // Only returns error if Reader fails (extremely rare, indicates system issue)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based suffix if crypto/rand fails
                return fmt.Sprintf("%d", time.Now().UnixNano()%1000000)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%x", bytes)</span>
}

// writeToTempFile writes encrypted data to temporary file with vault permissions (T012)
func (s *StorageService) writeToTempFile(path string, data []byte) error <span class="cov8" title="1">{
        // Create temp file with vault permissions (0600)
        file, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, VaultPermissions)
        if err != nil </span><span class="cov0" title="0">{
                // Check for disk space or permission errors
                if os.IsPermission(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrPermissionDenied, err)
                }</span>
                // Generic disk space or filesystem error
                <span class="cov0" title="0">return fmt.Errorf("%w: %v", ErrDiskSpaceExhausted, err)</span>
        }
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                // Close is best-effort - file already synced, data is on disk
                _ = file.Close()
        }</span>()

        // Write encrypted vault data
        <span class="cov8" title="1">if _, err := file.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to temporary file: %w", err)
        }</span>

        // Force flush to disk before verification (FR-015)
        <span class="cov8" title="1">if err := file.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync temporary file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// verifyTempFile decrypts and validates temporary file before commit (T020)
func (s *StorageService) verifyTempFile(path string, password string) error <span class="cov8" title="1">{
        // Read temp file
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: cannot read temporary file: %v", ErrVerificationFailed, err)
        }</span>

        // Parse as EncryptedVault structure
        <span class="cov8" title="1">var encryptedVault EncryptedVault
        if err := json.Unmarshal(data, &amp;encryptedVault); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: invalid vault structure: %v", ErrVerificationFailed, err)
        }</span>

        // Derive key from password and salt
        <span class="cov8" title="1">key, err := s.cryptoService.DeriveKey([]byte(password), encryptedVault.Metadata.Salt, encryptedVault.Metadata.Iterations)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: failed to derive key: %v", ErrVerificationFailed, err)
        }</span>
        <span class="cov8" title="1">defer s.cryptoService.ClearKey(key)

        // Decrypt vault data (in-memory verification)
        decryptedData, err := s.cryptoService.Decrypt(encryptedVault.Data, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: encrypted data could not be decrypted: %v", ErrVerificationFailed, err)
        }</span>
        // CRITICAL: Clear decrypted memory immediately after validation
        <span class="cov8" title="1">defer s.cryptoService.ClearData(decryptedData)

        // Verification successful - data decrypts correctly
        // Note: JSON structure validation is the responsibility of the vault layer
        // Storage layer only verifies that data can be decrypted successfully
        return nil</span>
}

// atomicRename performs atomic file rename (handles platform differences via os.Rename) (T013)
func (s *StorageService) atomicRename(oldPath, newPath string) error <span class="cov8" title="1">{
        if err := os.Rename(oldPath, newPath); err != nil </span><span class="cov0" title="0">{
                // Check for cross-device rename error (filesystem not atomic)
                if os.IsPermission(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %v", ErrPermissionDenied, err)
                }</span>
                // Cross-device or other filesystem error
                <span class="cov0" title="0">return fmt.Errorf("%w: %v", ErrFilesystemNotAtomic, err)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// cleanupTempFile removes temporary file (best-effort, logs warning if fails) (T031)
func (s *StorageService) cleanupTempFile(path string) error <span class="cov0" title="0">{
        if err := os.Remove(path); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Log warning but don't fail - cleanup is non-critical
                fmt.Fprintf(os.Stderr, "Warning: failed to remove temporary file %s: %v\n", path, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// cleanupOrphanedTempFiles removes old temp files from crashed previous saves (T032)
func (s *StorageService) cleanupOrphanedTempFiles(currentTempPath string) <span class="cov8" title="1">{
        vaultDir := filepath.Dir(s.vaultPath)
        pattern := filepath.Join(vaultDir, "*.tmp.*")

        matches, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                // Best-effort cleanup, ignore glob errors
                return
        }</span>

        <span class="cov8" title="1">for _, orphan := range matches </span><span class="cov8" title="1">{
                // Don't delete current temp file
                if orphan == currentTempPath </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Remove orphaned file from previous crashed save
                <span class="cov8" title="1">if err := os.Remove(orphan); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to remove orphaned temp file %s: %v\n", orphan, err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package storage

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "pass-cli/internal/crypto"
)

const (
        VaultPermissions = 0600 // Read/write for owner only
        DefaultVaultName = "vault.enc"
        BackupSuffix     = ".backup"
        TempSuffix       = ".tmp"
)

var (
        ErrVaultNotFound     = errors.New("vault file not found")
        ErrVaultCorrupted    = errors.New("vault file corrupted")
        ErrInvalidVaultPath  = errors.New("invalid vault path")
        ErrBackupFailed      = errors.New("backup operation failed")
        ErrAtomicWriteFailed = errors.New("atomic write operation failed")
)

type VaultMetadata struct {
        Version    int       `json:"version"`
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
        Salt       []byte    `json:"salt"`
        Iterations int       `json:"iterations"` // PBKDF2 iteration count (FR-007)
}

type EncryptedVault struct {
        Metadata VaultMetadata `json:"metadata"`
        Data     []byte        `json:"data"`
}

type StorageService struct {
        cryptoService *crypto.CryptoService
        vaultPath     string
}

func NewStorageService(cryptoService *crypto.CryptoService, vaultPath string) (*StorageService, error) <span class="cov8" title="1">{
        if cryptoService == nil </span><span class="cov8" title="1">{
                return nil, errors.New("crypto service cannot be nil")
        }</span>

        <span class="cov8" title="1">if vaultPath == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidVaultPath
        }</span>

        // Ensure the directory exists
        <span class="cov8" title="1">dir := filepath.Dir(vaultPath)
        if err := os.MkdirAll(dir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create vault directory: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;StorageService{
                cryptoService: cryptoService,
                vaultPath:     vaultPath,
        }, nil</span>
}

func (s *StorageService) InitializeVault(password string) error <span class="cov8" title="1">{
        // Check if vault already exists
        if s.VaultExists() </span><span class="cov8" title="1">{
                return errors.New("vault already exists")
        }</span>

        // Generate salt for key derivation
        <span class="cov8" title="1">salt, err := s.cryptoService.GenerateSalt()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate salt: %w", err)
        }</span>

        // Create initial empty vault data
        <span class="cov8" title="1">emptyVault := []byte("{}")

        // T032/T034: Create vault metadata with configurable iterations (FR-007, FR-010)
        // Uses PASS_CLI_ITERATIONS env var if set, otherwise defaults to 600k (OWASP 2023)
        metadata := VaultMetadata{
                Version:    1,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
                Salt:       salt,
                Iterations: crypto.GetIterations(), // Configurable via env var (T034)
        }

        // Encrypt and save vault
        if err := s.saveEncryptedVault(emptyVault, metadata, password); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize vault: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *StorageService) LoadVault(password string) ([]byte, error) <span class="cov8" title="1">{
        encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // T031: Derive key from password and salt with iterations from metadata (FR-007)
        <span class="cov8" title="1">key, err := s.cryptoService.DeriveKey([]byte(password), encryptedVault.Metadata.Salt, encryptedVault.Metadata.Iterations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive key: %w", err)
        }</span>
        <span class="cov8" title="1">defer s.cryptoService.ClearKey(key)

        // Decrypt vault data
        plaintext, err := s.cryptoService.Decrypt(encryptedVault.Data, key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decrypt vault (invalid password?): %w", err)
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}

func (s *StorageService) SaveVault(data []byte, password string) error <span class="cov8" title="1">{
        // Load existing vault to get metadata
        encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update metadata
        <span class="cov8" title="1">encryptedVault.Metadata.UpdatedAt = time.Now()

        // Prepare encrypted vault data
        encryptedData, err := s.prepareEncryptedData(data, encryptedVault.Metadata, password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("save failed: %w (your vault was not modified)", err)
        }</span>

        // T033: Step 0: Cleanup orphaned temp files from previous crashes (best-effort)
        <span class="cov8" title="1">s.cleanupOrphanedTempFiles("")

        // T014: Step 1: Generate temp filename
        tempPath := s.generateTempFileName()

        // Step 2: Write to temp file
        if err := s.writeToTempFile(tempPath, encryptedData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("save failed: %w (your vault was not modified)", err)
        }</span>

        // Ensure temp file cleanup on error
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                // Best-effort cleanup if we haven't renamed yet
                _ = os.Remove(tempPath)
        }</span>()

        // Step 3: Verification (T021 - verify temp file is decryptable)
        <span class="cov8" title="1">if err := s.verifyTempFile(tempPath, password); err != nil </span><span class="cov0" title="0">{
                // Cleanup temp file on verification failure
                _ = os.Remove(tempPath)
                return fmt.Errorf("save failed during verification (your vault was not modified): %w", err)
        }</span>

        // Step 4: Atomic rename (vault → backup)
        <span class="cov8" title="1">backupPath := s.vaultPath + BackupSuffix
        if err := s.atomicRename(s.vaultPath, backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("save failed: %w (your vault was not modified)", err)
        }</span>

        // Step 5: Atomic rename (temp → vault)
        <span class="cov8" title="1">if err := s.atomicRename(tempPath, s.vaultPath); err != nil </span><span class="cov0" title="0">{
                // CRITICAL ERROR: Try to restore backup
                _ = s.atomicRename(backupPath, s.vaultPath)
                return fmt.Errorf("CRITICAL: save failed during final rename. Attempted automatic restore from backup. Error: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// prepareEncryptedData encrypts vault data and returns JSON bytes ready to write
func (s *StorageService) prepareEncryptedData(data []byte, metadata VaultMetadata, password string) ([]byte, error) <span class="cov8" title="1">{
        // Derive key from password and salt
        key, err := s.cryptoService.DeriveKey([]byte(password), metadata.Salt, metadata.Iterations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to derive key: %w", err)
        }</span>
        <span class="cov8" title="1">defer s.cryptoService.ClearKey(key)

        // Encrypt vault data
        encryptedData, err := s.cryptoService.Encrypt(data, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt vault data: %w", err)
        }</span>

        // Create encrypted vault structure
        <span class="cov8" title="1">encryptedVault := EncryptedVault{
                Metadata: metadata,
                Data:     encryptedData,
        }

        // Marshal to JSON
        jsonData, err := json.Marshal(encryptedVault)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal vault data: %w", err)
        }</span>

        <span class="cov8" title="1">return jsonData, nil</span>
}

// SaveVaultWithIterations saves vault data with an updated iteration count.
// Used for migration from legacy iteration counts (T033).
func (s *StorageService) SaveVaultWithIterations(data []byte, password string, iterations int) error <span class="cov0" title="0">{
        if iterations &lt; crypto.MinIterations </span><span class="cov0" title="0">{
                return fmt.Errorf("iterations must be &gt;= %d", crypto.MinIterations)
        }</span>

        // T036d: Pre-flight checks before migration (FR-012)
        <span class="cov0" title="0">if err := s.preflightChecks(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pre-flight check failed: %w", err)
        }</span>

        // Load existing vault to get metadata
        <span class="cov0" title="0">encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update metadata with new iterations
        <span class="cov0" title="0">encryptedVault.Metadata.UpdatedAt = time.Now()
        encryptedVault.Metadata.Iterations = iterations

        // Create backup before saving
        if err := s.createBackup(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup: %w", err)
        }</span>

        // Save encrypted vault
        <span class="cov0" title="0">if err := s.saveEncryptedVault(data, encryptedVault.Metadata, password); err != nil </span><span class="cov0" title="0">{
                // Restore from backup on failure
                if restoreErr := s.restoreFromBackup(); restoreErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("save failed and backup restore failed: %v (original error: %w)", restoreErr, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to save vault: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SaveVaultWithIterationsUnsafe saves vault data with a specific iteration count without validation.
// ONLY FOR TESTING: Allows simulating legacy vaults with low iteration counts.
// DO NOT USE in production code.
func (s *StorageService) SaveVaultWithIterationsUnsafe(data []byte, password string, iterations int) error <span class="cov0" title="0">{
        // Load existing vault to get metadata
        encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update metadata with new iterations (no validation)
        <span class="cov0" title="0">encryptedVault.Metadata.UpdatedAt = time.Now()
        encryptedVault.Metadata.Iterations = iterations

        // Create backup before saving
        if err := s.createBackup(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup: %w", err)
        }</span>

        // Save encrypted vault
        <span class="cov0" title="0">if err := s.saveEncryptedVault(data, encryptedVault.Metadata, password); err != nil </span><span class="cov0" title="0">{
                // Restore from backup on failure
                if restoreErr := s.restoreFromBackup(); restoreErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("save failed and backup restore failed: %v (original error: %w)", restoreErr, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to save vault: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetIterations returns the current PBKDF2 iteration count from vault metadata.
// Returns 0 if vault doesn't exist or error occurs.
func (s *StorageService) GetIterations() int <span class="cov0" title="0">{
        encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return encryptedVault.Metadata.Iterations</span>
}

// SetIterations updates the PBKDF2 iteration count in vault metadata.
// This will take effect on the next SaveVault call.
// Used for migration from legacy iteration counts (T033).
func (s *StorageService) SetIterations(iterations int) error <span class="cov0" title="0">{
        if iterations &lt; crypto.MinIterations </span><span class="cov0" title="0">{
                return fmt.Errorf("iterations must be &gt;= %d", crypto.MinIterations)
        }</span>

        <span class="cov0" title="0">encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryptedVault.Metadata.Iterations = iterations

        // Note: The updated iterations will be persisted on next SaveVault call
        // We don't save immediately to avoid double-write overhead
        return nil</span>
}

func (s *StorageService) VaultExists() bool <span class="cov8" title="1">{
        _, err := os.Stat(s.vaultPath)
        return err == nil
}</span>

func (s *StorageService) GetVaultInfo() (*VaultMetadata, error) <span class="cov8" title="1">{
        encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Return a copy of metadata (without the salt for security)
        <span class="cov8" title="1">info := VaultMetadata{
                Version:   encryptedVault.Metadata.Version,
                CreatedAt: encryptedVault.Metadata.CreatedAt,
                UpdatedAt: encryptedVault.Metadata.UpdatedAt,
                Salt:      nil, // Don't expose salt
        }

        return &amp;info, nil</span>
}

func (s *StorageService) ValidateVault() error <span class="cov8" title="1">{
        encryptedVault, err := s.loadEncryptedVault()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Basic validation checks
        <span class="cov8" title="1">if encryptedVault.Metadata.Version &lt;= 0 </span><span class="cov8" title="1">{
                return ErrVaultCorrupted
        }</span>

        <span class="cov8" title="1">if len(encryptedVault.Metadata.Salt) != 32 </span><span class="cov8" title="1">{
                return ErrVaultCorrupted
        }</span>

        <span class="cov8" title="1">if len(encryptedVault.Data) == 0 </span><span class="cov8" title="1">{
                return ErrVaultCorrupted
        }</span>

        <span class="cov8" title="1">if encryptedVault.Metadata.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                return ErrVaultCorrupted
        }</span>

        <span class="cov8" title="1">if encryptedVault.Metadata.UpdatedAt.Before(encryptedVault.Metadata.CreatedAt) </span><span class="cov8" title="1">{
                return ErrVaultCorrupted
        }</span>

        // Validate Iterations field (T025 - FR-007)
        // Allow 0 for backward compatibility (will default to 100000 on load)
        <span class="cov8" title="1">if encryptedVault.Metadata.Iterations != 0 &amp;&amp; encryptedVault.Metadata.Iterations &lt; crypto.MinIterations </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: iterations must be &gt;= %d", ErrVaultCorrupted, crypto.MinIterations)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *StorageService) CreateBackup() error <span class="cov8" title="1">{
        return s.createBackup()
}</span>

func (s *StorageService) RestoreFromBackup() error <span class="cov8" title="1">{
        return s.restoreFromBackup()
}</span>

func (s *StorageService) RemoveBackup() error <span class="cov8" title="1">{
        backupPath := s.vaultPath + BackupSuffix
        err := os.Remove(backupPath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil // Backup doesn't exist, which is fine
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Private helper methods

func (s *StorageService) loadEncryptedVault() (*EncryptedVault, error) <span class="cov8" title="1">{
        if !s.VaultExists() </span><span class="cov8" title="1">{
                return nil, ErrVaultNotFound
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(s.vaultPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read vault file: %w", err)
        }</span>

        <span class="cov8" title="1">var encryptedVault EncryptedVault
        if err := json.Unmarshal(data, &amp;encryptedVault); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse vault file: %w", err)
        }</span>

        // T026: Backward compatibility for legacy vaults without Iterations field (FR-008)
        <span class="cov8" title="1">if encryptedVault.Metadata.Iterations == 0 </span><span class="cov8" title="1">{
                encryptedVault.Metadata.Iterations = 100000 // Legacy default
        }</span>

        <span class="cov8" title="1">return &amp;encryptedVault, nil</span>
}

func (s *StorageService) saveEncryptedVault(data []byte, metadata VaultMetadata, password string) error <span class="cov8" title="1">{
        // T030: Derive key from password and salt with iterations from metadata (FR-007)
        key, err := s.cryptoService.DeriveKey([]byte(password), metadata.Salt, metadata.Iterations)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to derive key: %w", err)
        }</span>
        <span class="cov8" title="1">defer s.cryptoService.ClearKey(key)

        // Encrypt vault data
        encryptedData, err := s.cryptoService.Encrypt(data, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt vault data: %w", err)
        }</span>

        // Create encrypted vault structure
        <span class="cov8" title="1">encryptedVault := EncryptedVault{
                Metadata: metadata,
                Data:     encryptedData,
        }

        // Marshal to JSON
        jsonData, err := json.Marshal(encryptedVault)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal vault data: %w", err)
        }</span>

        // Atomic write using temporary file
        <span class="cov8" title="1">return s.atomicWrite(s.vaultPath, jsonData)</span>
}

func (s *StorageService) atomicWrite(path string, data []byte) error <span class="cov8" title="1">{
        // FR-015: Create parent directories if they don't exist
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        <span class="cov8" title="1">tempPath := path + TempSuffix

        // Write to temporary file
        // #nosec G304 -- Vault path is user-controlled by design for CLI tool
        tempFile, err := os.OpenFile(tempPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, VaultPermissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>

        // Ensure temp file is cleaned up on error
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if tempFile != nil </span><span class="cov0" title="0">{
                        _ = tempFile.Close()
                        _ = os.Remove(tempPath)
                }</span>
        }()

        // Write data
        <span class="cov8" title="1">if _, err := tempFile.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write data: %w", err)
        }</span>

        // Sync to ensure data is written to disk
        <span class="cov8" title="1">if err := tempFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync data: %w", err)
        }</span>

        // Close file
        <span class="cov8" title="1">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close temp file: %w", err)
        }</span>
        <span class="cov8" title="1">tempFile = nil // Prevent cleanup in defer

        // Atomic move (rename) to final location
        if err := os.Rename(tempPath, path); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tempPath) // Clean up on failure
                return fmt.Errorf("failed to move temp file to final location: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// preflightChecks performs safety checks before migration (T036d, FR-012).
// Verifies:
// - Disk space &gt;= 2x vault size (to accommodate backup + new vault)
// - Write permissions to vault directory
func (s *StorageService) preflightChecks() error <span class="cov0" title="0">{
        // Check if vault exists
        vaultInfo, err := os.Stat(s.vaultPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat vault: %w", err)
        }</span>

        <span class="cov0" title="0">vaultSize := vaultInfo.Size()
        vaultDir := filepath.Dir(s.vaultPath)

        // Check disk space (need 2x vault size for backup + new vault)
        requiredSpace := vaultSize * 2

        // Get disk usage info (platform-specific)
        availableSpace, err := s.getAvailableDiskSpace(vaultDir)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't determine disk space, log warning but continue
                fmt.Fprintf(os.Stderr, "Warning: unable to verify disk space: %v\n", err)
        }</span> else<span class="cov0" title="0"> if availableSpace &lt; requiredSpace </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient disk space: need %d bytes, have %d bytes", requiredSpace, availableSpace)
        }</span>

        // Test write permissions by creating a temporary test file
        <span class="cov0" title="0">testPath := filepath.Join(vaultDir, ".pass-cli-write-test")
        testFile, err := os.OpenFile(testPath, os.O_WRONLY|os.O_CREATE|os.O_EXCL, VaultPermissions) // #nosec G304 -- Test file path constructed from validated vault directory
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no write permission in vault directory: %w", err)
        }</span>
        <span class="cov0" title="0">_ = testFile.Close()
        _ = os.Remove(testPath)

        return nil</span>
}

// getAvailableDiskSpace returns available disk space in bytes for the given path.
// Platform-specific implementation.
func (s *StorageService) getAvailableDiskSpace(path string) (int64, error) <span class="cov0" title="0">{
        // Platform-specific disk space check
        // On Windows, syscall.Statfs_t is not available
        // This is a best-effort check - we'll continue with a warning if it fails

        // Try to use platform-specific approach
        // For Windows: Could use golang.org/x/sys/windows.GetDiskFreeSpaceEx
        // For Unix: Could use syscall.Statfs

        // For now, return error to indicate we can't check (will trigger warning in preflightChecks)
        // This is acceptable per FR-012 - disk space check is a safety measure, not a hard requirement
        return 0, fmt.Errorf("disk space check not implemented for this platform")
}</span>

func (s *StorageService) createBackup() error <span class="cov8" title="1">{
        if !s.VaultExists() </span><span class="cov8" title="1">{
                return nil // No vault to backup
        }</span>

        <span class="cov8" title="1">backupPath := s.vaultPath + BackupSuffix

        // Copy vault file to backup
        src, err := os.Open(s.vaultPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open vault for backup: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = src.Close() }</span>()

        // #nosec G304 -- Backup path is user-controlled by design for CLI tool
        <span class="cov8" title="1">dst, err := os.OpenFile(backupPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, VaultPermissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup file: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = dst.Close() }</span>()

        <span class="cov8" title="1">if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy vault to backup: %w", err)
        }</span>

        <span class="cov8" title="1">if err := dst.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync backup file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *StorageService) restoreFromBackup() error <span class="cov8" title="1">{
        backupPath := s.vaultPath + BackupSuffix

        if _, err := os.Stat(backupPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return ErrBackupFailed
        }</span>

        // Copy backup to vault location
        // #nosec G304 -- Backup path is user-controlled by design for CLI tool
        <span class="cov8" title="1">src, err := os.Open(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open backup file: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = src.Close() }</span>()

        <span class="cov8" title="1">dst, err := os.OpenFile(s.vaultPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, VaultPermissions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create vault file: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ _ = dst.Close() }</span>()

        <span class="cov8" title="1">if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore from backup: %w", err)
        }</span>

        <span class="cov8" title="1">if err := dst.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync restored vault: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
