## Notes and observations:

#### Legend
- [Q] = Question
- [A] = Answer/Investigation Result

===

- When running just the command pass-cli, if no vault is identified at the default vault location - instead of attempting to unlock the vault show a message to setup a vault
  - Simlarly on the first detected run of pass-cli, offer to initalize a vault: perhaps we need to expand some instructions on that.

- Add a "pass-cli doctor" command to verify the installation and status of pass-cli is healthy (i.e., the app is up-to-date, a default vault has been found, no config issues, etc.)

- The popular commands (for example: add, get, update, list) should have flags or a second shorter alias for faster command entry. 
  - Also, we should switch -v from verbose to vault

- [Q] If a vault has been removed, and it used keychain to enable it when it was first initialized, are we cleaning up that keychain information
  - [A] **No cleanup occurs**. There's no command to remove an entire vault (only `delete` for credentials). If a user manually deletes the vault file, keychain entries remain orphaned. `internal/keychain/keychain.go:94-105` has Delete/Clear methods, but they're never called during vault removal. **Gap identified**: Need vault removal command that cleans up keychain.

- [Q] Can keychain only be enabled during a vaults initialization?
  - [A] **Yes, currently keychain is init-only**. `cmd/init.go:44` - `--use-keychain` flag only available on `init` command. No command exists to enable keychain for existing vaults. However, `change-password` DOES update keychain if it's already enabled. **Workaround**: Users can manually add via `change-password` if they know the keychain service is available.

- [Q] Should we create a command to inspect and verify the status of the keychain manager on the environment where pass-cli is set-up?
  - [A] **Does not exist currently**. No command to inspect keychain status. Would be useful to show: (1) Is keychain available on this system? (2) Is password stored for current vault? (3) What keychain backend is being used? **Pairs well with**: Proposed `doctor` command.

- [Q] Our 'change-password' command, does this also update the password that's inserted into the keychain?
  - [A] **Yes** - `internal/vault/vault.go:819-823`. Code always attempts to update keychain if available, logs warning on failure but doesn't block operation. This ensures keychain stays in sync with vault password.

- [Q] should we employ a bottom to top approach for identifying what vault to work with? similar to Claude's structure:
  - Bottom's up? If vault is not specified, then first look in the project root of where the pass-cli command is being called. If a vault isn't present then look globally (at the default location).
  - Additionally, we can add flags like -g or -gv for global vault and -p or -pv for project vault (if that makes sense and it doesn't conflict with anything).
    - [Q] Maybe -pv and -gv replaces --vault (-v)? Or would it compliment the existing ?

- Parallel to the above should we add structures to check for .pass-cli when present in folders, that way we can also track where other vaults are perhaps around the envrionment, if any? We can introduce the 'pass-cli vaults' command which can list the available vaults on the system (if possible?)

- [Q] How and when are the vault backup files created, is it not part of our standard operational flow? When we originally created vaults it created both the vault.enc file and the vault.enc.backup file.
  - [A] **Automatic on every save** - `internal/storage/storage.go:134-137`. Created before EVERY `SaveVault()` operation. Removed after successful unlock - `internal/vault/vault.go:334-342`. **Purpose**: Safety net for interrupted operations. **Lifecycle**: Persists between sessions, cleaned up on next successful unlock. **When created**: Adding/updating/deleting credentials, changing password, any vault modification.
===

##### Add to config(?)
- Adjust default vault location (?) where to check first instead of the default vault location; need to inspect this further - if this tweak makes sense

===

##### Documentation

- Noticing the use of January 2025 in some locations, but that doesn't match the actual date of when things were updated.
- Notice the mention of certain paths like config are mentioning locations that don't match what our docs and/or the cli commands and helper text information outputs.

===

## Design Decisions & Reasoning

### Auto-Cleanup Strategy

**Decision**: NO automatic cleanup on startup/shutdown. Only cleanup on explicit user actions.

**Reasoning**:
- **The False Positive Problem**: App cannot distinguish between "vault deleted forever" vs "vault temporarily unavailable"
  - Network drives temporarily disconnected
  - Cloud sync conflicts (Dropbox moves to `.conflicted`)
  - User typo in `--vault` flag path
  - Unmounted drives or USB storage
- **Auto-cleanup would be destructive and surprising** when vault reappears
- **User convenience preserved**: Keychain continues to work seamlessly across sessions

**When Automatic Cleanup IS Safe**:
- `pass-cli vault remove` command - User intent is explicit and unambiguous
- No false positive risk when user explicitly requests removal

**Philosophy**: Automatic cleanup without user intent = dangerous guesswork. With explicit intent = fulfilling user's request.

### Keychain Persistence Model

**Decision**: Keep persistent keychain for both CLI and TUI modes (no session-based cleanup).

**Reasoning**:
- **User expectation**: Users who enable keychain chose convenience over maximum security
- **CLI requirement**: Each command is a separate process; session-based would require password on EVERY invocation
- **TUI convenience**: Current UX where TUI launches without password is valuable and should not break
- **Security trade-off**: Orphaned entries are a cleanup problem, not an immediate security crisis
  - If attacker has keychain access, they already have everything
  - Risk is manageable with proper cleanup tools

**Alternative Considered**: Gemini's session-based model (clear keychain on exit)
- **Rejected because**: Breaks existing UX convenience that users rely on
- **Good for**: Long-lived daemon processes (not our architecture)

### Cleanup Tools Approach

**Decision**: Provide multiple cleanup mechanisms for different use cases.

**Tools**:
1. `pass-cli vault remove` → Automatic keychain cleanup (no confirmation)
2. `pass-cli doctor` → Detect orphans, offer cleanup
3. `pass-cli keychain clear` → Manual cleanup command
4. `--ephemeral-keychain` flag → Opt-in per-command cleanup for security-conscious users

**Reasoning**: Balance between safety, control, and flexibility. Users stay in control without surprises.

### Spec Organization

**Decision**: Create one comprehensive spec covering all single-vault improvements.

**Reasoning**:
- **Dependencies**: Doctor command needed by multiple features (keychain, vault management)
- **Flag conflicts**: `-v` switch and new flags need coordinated design
- **Sequential nature**: Multi-vault support should build on single-vault foundation
- **Cohesion**: All improvements target current single-vault UX

**Split approach rejected**: Too many cross-spec dependencies would create integration issues and duplicate work.

===

## Investigation Recommendations

### High Priority
1. **Add vault removal command with keychain cleanup** - Close the gap where orphaned keychain entries remain
2. **Add keychain status inspection** - Either standalone or part of `doctor` command
3. **Add command to enable keychain post-init** - Allow users to add keychain to existing vaults

### Medium Priority
4. **Implement `doctor` command** - Check binary version, vault presence, config validity, keychain status
5. **Command aliases** - Add shorter aliases for popular commands (add, get, update, list)
6. **Switch `-v` flag** - Change from verbose to vault (more intuitive)

### Needs Design/Spec
7. **Bottom-up vault resolution** - Project-local vaults before global (like git, npm)
8. **Vault discovery mechanism** - `.pass-cli` marker files + `pass-cli vaults` command
9. **Config default vault location** - Allow users to override default resolution

### Documentation Cleanup
10. **Document backup file lifecycle** - Explain when created/removed
11. **Audit date references** - Fix January 2025 inconsistencies
12. **Verify path references** - Ensure docs match actual implementation

===

