## Notes and Observations v2: Single-Vault Core Improvements

**Date**: 2025-10-20
**Evolution from**: n-n-o-1017.md - refined for single-vault architecture

#### Legend
- [Q] = Question
- [A] = Answer/Investigation Result

===

## Architectural Clarity

**Pass-cli is architected for one vault per user, with organization via usage tracking:**

- **One vault** at standard location (`$HOME/.pass-cli/vault.enc`)
- **Multi-location tracking** - Each credential tracks usage across multiple directories/projects
  - Location (working directory)
  - Git repository context
  - Field-level access (password:3, username:2, etc.)
  - Timestamp and access counts
- **Simple categorization** - Category field for basic organization (Work, Personal, etc.)
- **Result**: Single vault eliminates complexity while sophisticated tracking provides context-based organization

**Evidence**:
- `internal/vault/vault.go:29-36` - UsageRecord struct with location, git repo, field-level tracking
- `internal/vault/vault.go:50` - Credential.UsageRecord map[string]UsageRecord
- `cmd/tui/components/detail.go:340-395` - TUI beautifully displays multi-location usage
- `cmd/list.go` - Commands like `list --unused --days N` leverage tracking
- `cmd/verify_audit.go` - Audit access patterns across locations

===

## Core Observations

### First-Run Experience

- When running `pass-cli` with no vault at default location, instead of error, offer to initialize THE vault
- On first detected run, guide user through vault setup with clear instructions
- Make vault initialization seamless and intuitive

### Doctor Command

- Add `pass-cli doctor` command to verify installation health:
  - App is up-to-date
  - Default vault found and accessible
  - No config issues
  - Keychain status (if enabled)
  - Backup file status

### Command Aliases

- Popular commands (add, get, update, list) should have shorter aliases for faster entry
- Examples: `pass-cli a`, `pass-cli g`, `pass-cli u`, `pass-cli l`
- Improves CLI ergonomics for frequent operations

### Keychain Lifecycle Gaps

- [Q] If a vault is removed, and it used keychain, are we cleaning up keychain entries?
  - [A] **No cleanup occurs** - `internal/keychain/keychain.go:94-105` has Delete/Clear methods but never called during vault removal. **Gap**: Need vault removal command that cleans up keychain.

- [Q] Can keychain only be enabled during vault initialization?
  - [A] **Yes, currently init-only** - `cmd/init.go:44` has `--use-keychain` flag. No command to enable for existing vaults. However, `change-password` DOES update keychain if already enabled. **Workaround needed**.

- [Q] Should we create a command to inspect keychain status?
  - [A] **Does not exist** - No command to show: (1) Is keychain available? (2) Is password stored? (3) What backend is used? **Pairs well with**: `doctor` command.

- [Q] Does `change-password` update keychain password?
  - [A] **Yes** - `internal/vault/vault.go:819-823` always attempts to update keychain if available.

### Backup File Lifecycle

- [Q] How and when are vault backup files created?
  - [A] **Automatic on every save** - `internal/storage/storage.go:134-137`. Created before EVERY `SaveVault()` operation. Removed after successful unlock - `internal/vault/vault.go:334-342`. **Purpose**: Safety net for interrupted operations. **Lifecycle**: Persists between sessions, cleaned up on next successful unlock.

===

## Underutilized Features

### Usage Tracking is a Hidden Gem

Pass-cli has sophisticated usage tracking that's underexposed:

**What exists** (`internal/vault/vault.go:29-36`):
- Location tracking (working directory where credential accessed)
- Git repository context
- Field-level access counts (`password:5, username:2`)
- Timestamp and total access counts per location

**Current exposure**:
- **TUI detail view** (`cmd/tui/components/detail.go:340-395`) - Shows beautiful formatted usage:
  ```
  /path/to/project:42 (my-repo) - 2 hours ago - accessed 5 times (password:3, username:2)
  ```
- **CLI commands**:
  - `list --unused` - Filter credentials not used recently
  - `list --days N` - Filter by last access time
  - `verify-audit` - Audit access patterns

**Opportunity**:
- This IS the single-vault differentiation - organize by context, not containers
- More CLI commands to leverage tracking:
  - `pass-cli usage <service>` - Show detailed usage view like TUI
  - `pass-cli list --by-project` - Group credentials by project/repo
  - `pass-cli list --location <path>` - Filter by location
- Prominently document this feature in README/docs
- This eliminates need for multiple vaults - one vault, organized by usage context

===

## Design Decisions & Reasoning

### Auto-Cleanup Strategy

**Decision**: NO automatic cleanup on startup/shutdown. Only cleanup on explicit user actions.

**Reasoning**:
- **The False Positive Problem**: App cannot distinguish between "vault deleted forever" vs "vault temporarily unavailable"
  - Network drives temporarily disconnected
  - Cloud sync conflicts (Dropbox moves to `.conflicted`)
  - User typo in `--vault` flag path
  - Unmounted drives or USB storage
- **Auto-cleanup would be destructive and surprising** when vault reappears
- **User convenience preserved**: Keychain continues to work seamlessly across sessions

**When Automatic Cleanup IS Safe**:
- `pass-cli vault remove` command - User intent is explicit and unambiguous
- No false positive risk when user explicitly requests removal

**Philosophy**: Automatic cleanup without user intent = dangerous guesswork. With explicit intent = fulfilling user's request.

### Keychain Persistence Model

**Decision**: Keep persistent keychain for both CLI and TUI modes (no session-based cleanup).

**Reasoning**:
- **User expectation**: Users who enable keychain chose convenience over maximum security
- **CLI requirement**: Each command is a separate process; session-based would require password on EVERY invocation
- **TUI convenience**: Current UX where TUI launches without password is valuable and should not break
- **Security trade-off**: Orphaned entries are a cleanup problem, not an immediate security crisis
  - If attacker has keychain access, they already have everything
  - Risk is manageable with proper cleanup tools

**Alternative Considered**: Session-based model (clear keychain on exit)
- **Rejected because**: Breaks existing UX convenience that users rely on
- **Good for**: Long-lived daemon processes (not our architecture)

### Single-Vault Architecture Rationale

**Decision**: Pass-cli operates on one vault per user model.

**Reasoning**:
- **Simpler mental model**: One source of truth, no "which vault?" questions
- **Usage tracking eliminates need for separation**: Multi-location tracking provides context
  - Credentials automatically track where they're used (project paths, git repos)
  - Field-level access shows what's being accessed and how often
  - Temporal data shows recent vs. stale credentials
- **No vault proliferation**: Avoid "work vault", "personal vault", "project vault" complexity
- **Organization via attributes**: Category field + usage context = powerful organization without containers

**The `--vault` Flag Problem**:
- Currently `--vault` flag is prominent in all commands (`cmd/root.go:67`)
- **Creates wrong impression**: Implies multi-vault is normal, single-vault is special case
- **Reality**: 99% of users use default vault location
- **Solution**: De-emphasize in help/docs, clarify it's for edge cases (testing, CI/CD, alternate locations)

### Cleanup Tools Approach

**Decision**: Provide multiple cleanup mechanisms for different use cases.

**Tools**:
1. `pass-cli vault remove` → Automatic keychain cleanup (no confirmation)
2. `pass-cli doctor` → Detect orphans, offer cleanup
3. `pass-cli keychain clear` → Manual cleanup command
4. `--ephemeral-keychain` flag → Opt-in per-command cleanup for security-conscious users

**Reasoning**: Balance between safety, control, and flexibility. Users stay in control without surprises.

===

## Investigation Recommendations

### High Priority

1. **Add vault removal command with keychain cleanup** - Close the gap where orphaned keychain entries remain
   - `pass-cli vault remove` with automatic keychain cleanup
   - Explicit user intent = safe to cleanup

2. **Add keychain status inspection** - Either standalone or part of `doctor` command
   - Is keychain available on this system?
   - Is password stored for current vault?
   - What keychain backend is being used?

3. **Add command to enable keychain post-init** - Allow users to add keychain to existing vaults
   - Currently keychain is init-only (`cmd/init.go:44`)
   - Users should be able to opt-in later

4. **Implement `doctor` command** - Check binary version, vault presence, config validity, keychain status
   - Validates THE vault's health
   - Detects orphaned keychain entries
   - Checks backup file status
   - Verifies app is up-to-date

5. **Command aliases** - Add shorter aliases for popular commands
   - `a` = add, `g` = get, `u` = update, `l` = list
   - Improves CLI ergonomics

6. **First-run detection and guided initialization** - Make vault setup seamless
   - Detect when no vault exists at default location
   - Offer to initialize THE vault with guided prompts
   - Clear, friendly onboarding experience

7. **De-emphasize `--vault` flag** - Clarify it's for edge cases
   - Update help text to show it's optional/advanced
   - Document that default location is standard for 99% of users
   - Prevent wrong impression that multi-vault is normal

8. **Enhanced usage tracking exposure** - Better CLI/TUI visibility
   - `pass-cli usage <service>` - Show detailed usage like TUI detail view
   - `pass-cli list --by-project` - Group by git repo/project
   - `pass-cli list --location <path>` - Filter by directory
   - Prominently document in README as key differentiator

### Medium Priority

9. **Documentation cleanup** - Fix inconsistencies
   - Audit date references (January 2025 inconsistencies)
   - Verify path references match actual implementation
   - Document backup file lifecycle clearly

10. **Document backup file lifecycle** - Explain when created/removed
    - Created before every save operation
    - Removed after successful unlock
    - Safety net for interrupted operations

===

## Removed from v1 (for reference)

The following items from n-n-o-1017.md were removed in v2 and why:

**Item 6: Switch `-v` from verbose to vault**
- **Why removed**: Conflicts with existing `-v` verbose flag
- **Problem**: Optimizes for edge case (specifying vault) at expense of common case (verbose logging)
- **Better approach**: De-emphasize `--vault` long flag instead of changing `-v` short flag

**Items 7-9: Multi-vault features**
- Bottom-up vault resolution (project vault vs. global vault)
- Vault discovery mechanism (`.pass-cli` marker files, `pass-cli vaults` command)
- Config default vault location

- **Why removed**: Conflicts with single-vault architecture
- **Architectural insight**: One vault + usage tracking eliminates need for vault proliferation
- **Evidence**: Existing UsageRecord tracks multi-location usage, providing context without separate vaults

===

## Summary: Ready for Spec Creation

This document is now focused on **single-vault core improvements**:

**Scope for spec(s)**:
1. **Critical keychain improvements** (items 1-3) - High-value, well-defined
2. **First-run and doctor** (items 4, 6) - Essential UX improvements
3. **Enhanced usage tracking exposure** (item 8) - Leverage existing strength
4. **Command aliases** (item 5) - Quick win for ergonomics
5. **Documentation** (items 9-10) - Cleanup and clarity

**Not included**:
- Multi-vault features (removed as conflicting with architecture)
- `-v` flag switch (removed as creating unnecessary complexity)

**Next step**: Create spec for critical improvements, likely split into 2-3 focused specs by priority.
